# [1954] 달팽이 숫자

## :pushpin: **Algorithm**

구현, 시뮬레이션

## :round_pushpin: **Logic**

```java
while(n <= N*N) {
    if (isIn(x, y) && map[x][y] == 0)
        map[x][y] = n++;
    else {
        x -= dir[d][0];
        y -= dir[d][1];
        d = (d + 1) % 4;
    }

    x += dir[d][0];
    y += dir[d][1];
}
```

- 올바른 범위 내이고
  - 현재 좌표의 값이 0이라면 n을 쓴다.
  - 0이 아니라 이미 값이 채워져있다면, 현재 좌표 이전 좌표에서 방향을 전환한다.
- 올바른 범위 내가 아니라면,
  - 현재 좌표 이전 좌표에서 방향을 전환한다.
- 현재 방향으로 다음 좌표를 계산한다.

## :black_nib: **Review**
- 이전 코테에서도 이런 달팽이 모양의 배열을 탐색하고 하는 문제를 본 기억이 있어서 한 번 풀어보았다.
- 아이디어는 쉽게 잡았으나 조건을 나눠 인덱스를 옮겨주는 부분에서 오래 걸렸다.